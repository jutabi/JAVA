### 힙
- 완전 이진트리를 기본으로 한다.
- min heap 은 최소값을 뿌리노드에,  
  max head 은 최대값을 뿌리노드에 위치시켜 노드들의 최대값과 최소값을
구하기 쉽게 한다.
- 힙 내부는 첫번째 값이 최대값이나 최소값이지만 나머지 노드들이 인덱스
순서대로 정렬되어있지는 않다.

### 힙 정렬
- 힙의 특성상 최소값이나 최대값이 뿌리 노드에 위치하는 것을 이용한 정렬방법.
- 정렬시키고 싶은 숫자들을 힙에 집어 넣고 뿌리노드에서 숫자를 꺼내어 정렬한다.

#### 힙의 구현 방법
#### 노드의 삽입 (min heap)
1. 마지막 노드에 원하는 숫자를 삽입한다.
2. 삽입한 노드가 부모 노드가 있는지 확인한다.  
   (부모노드 = 바닥함수(현재 위치 / 2) => 인덱스 3의 부모 = 1)  
   (프로그래밍에서는 인덱스가 0부터 시작함으로 +1을 해서 계산하고 계산후
   -1을 진행한다.)
3. 부모노드가 있다면 부모노드의 값보다 삽입한 값이 작을 경우 서로의 값을  
바꿔주고 탐색하고 있는 인덱스도 부모의 자리로 변경해준다.  
   (인덱스 3이 부모인 인덱스1보다 작다면 서로의 값을 바꾸고 인덱스3을 1로 변경)
4. 탐색중인 인덱스가 뿌리 노드(인덱스 첫번째)와 비교될 때까지 반복을 진행한다.

#### 뿌리노드의 삭제 (min heap)
- 노드들중 최소값을 빼내고 두번째 최소값으로 뿌리노드를 대체시키는 것
1. 빼낼 노드가 있는지 검사한다.
2. 있다면 뿌리노드를 삭제한다. (정렬의 목적이라면 따로 저장해둔다)
3. 탐색할 인덱스 변수를 0 (뿌리노드)로 설정한다.
4. 뿌리 노드를 삭제하고나서 남은 노드들이 부모와 자식의 관계를 가질 수 있는지
검사한다. (list.size() > 1)
5. 삭제된 뿌리 노드의 자리 (인덱스 0)에 인덱스 맨 끝값을 집어 넣고 원본값은 
삭제한다.
6. 탐색할 노드 (첫번째 기준 인덱스 뿌리노드 0)가 자식을 가지고 있을 때까지 
자식들을 탐색하는 반복문을 작성한다.
   ( while ((((index + 1) * 2) - 1) < list.size()) )
   >heap 에서 자식 노드 2개를 찾는 공식  
   시작 인덱스가 1이라면 *2, *2 + 1 인 2번째, 3번째 노드가 자식 노드이지만  
   프로그래밍에서는 인덱스가 0부터 시작함으로 부모 노드의 인덱스 +1하고 계산한 뒤 - 1  
   root_index * 2 -> ((root_index + 1) * 2) - 1 - > (root_index + 1) * 2 - 1  
   root_index * 2 + 1 -> (((root_index + 1) * 2) + 1) - 1 - > (root_index + 1) * 2  
   > 
7. 두번째 자식이 리스트의 크기보다 크거나 같으면 = 자식이 한명밖에 없다면 
   혹은 첫번째 자식의 값이 두번째 자식의 값보다 작다면 비교 대상을 첫번째 자식으로 설정하고  
    그 이외의 경우 (자녀가 두명이며, 두번쨰 자식의 값이 첫번째 자식의 값보다 작으면)
    비교대상을 두번째 자식으로 설정한다.
8. 자식 노드와 비교하여 자식 노드의 값이 더 작다면 서로의 값을 교환해주고
탐색할 인덱스 변수의 값도 자식 노드의 인덱스로 변경한다.
9. 반복을 하다 자식노드보다 자신의 값이 더 작다면 서로의 값을 교환하지 않고 
반복문을 종료한다. (break or 인덱스를 맨 끝값으로 옮기기)