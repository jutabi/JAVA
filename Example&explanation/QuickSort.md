### 퀵 정렬
1. 퀵정렬 함수에 배열, 배열 첫번재 값의 인덱스(left),
   배열의 마지막 값의 인덱스(right)를 전달한다.
2. 피봇은 left, low는 left+1, high는 right로 설정한다.
3. 먼저 right가 left보다 큰지 확인한다.
4. 크다면 low가 high보다 작을때 까지 반복하는 반복문을 작성한다.
5. 먼저 low의 값(arr[low])이 pivot의 값(arr[pivot])보다 작거나 같고  
low가 right보다 작을 때 까지 low의 인덱스를 오른쪽으로 +1 해준다.  
   (피봇의 값보다 큰 값을 right에 닿을 때 까지 왼쪽에서부터 찾는다.)
6. high의 값(arr[high])이 pivot의 값(arr[pivot])보다 크고
high가 left보다 클 때 까지 high의 인덱스를 왼쪽으로 -1 해준다.  
   (피봇의 값보다 작은 값을 left에 닿을 때 까지 오른쪽에서부터 찾는다.)
7. low와 high의 이동이 끝났다면 (설령 값을 찾지 못하였더라도 "low는 right보다
작을 때까지, high는 left보다 클 때까지 이동"이라는 조건때문에 이동이 끝나게 
되어있다.) low의 인덱스가 high의 인덱스보다 작은지 확인한다.
    - low의 인덱스가 high보다 작다면 서로의 값 (arr[left], arr[right])을 교환
   하여준다.
8. 다시 반복문의 시작점으로 돌아가 low가 아직도 high보다 작은지 확인한다.
   - 작다면 low와 high의 이동을 다시 수행한다.
9. 이제 low가 high보다 더 커졌다면 (서로 움직이며 지나쳤다면) 반복문을
빠져나와 high의 값(arr[high])이 pivot의 값(arr[pivot])의 값보다 작거나
같은지를 확인한다.
    - 조건이 성립한다면 서로의 값을 바꿔주고 pivot의 인덱스를  high로 바꿔준다.
      - pivot의 인덱스 자리는 값이 결정되었다는 것.
10. 다시 퀵소트를 재귀함수로 호출하는데 피봇의 왼쪽 부분과 오른쪽 부분을 인자로
전달한다.
    - arr = 퀵 정렬(arr, left, pivot - 1)
    - arr = 퀵 정렬(arr, pivot + 1, right)
11. 함수를 마치며 인자로 전달받은 배열을 반환한다.


#### 예제) 왼쪽에 pivot을 두었을 때
##### 1. 
   - |7|4|5|9|2|
     |---|---|---|---|---|
     | left |  |  |  | right
     | pivot | low |  |  | high

   - pivot은 left, low는 left+1, high는 right값으로 설정한다.
   - low의 값이 pivot의 값보다 같거나 작다면 오른쪽으로 이동  
   (단, low < high가 성립하여야 한다.)


##### 2. 
   - |7|4|5|9|2|
     |---|---|---|---|---|
     | left |  |  |  | right
     | pivot |  |  | low | high

   - low를 이동시킨 뒤, high의 값이 pivot의 값보다 크다면 왼쪽으로 이동  
     (단, high > left가 성립하여야 한다.)
   - 여기서는 high의 값(2)이 pivot의 값(7)보다 작으므로 이동시키지 않는다.


##### 3. if (low < high) { low와 high의 값 교환}
   - low와 high를 이동시키고 나서 둘의 인덱스를 비교한다.
   low가 high보다 작다면 서로의 값을 교환한다.


##### 4.
   - |7|4|5|2|9|
     |---|---|---|---|---|
     | left |  |  |  | right
     | pivot |  |  | low | high
   - 다시 low를 오른쪽으로 옮겨주는 작업을 실시한다.
   여기서는 low<right가 성립하기때문에 low를 오른쪽으로 한칸 옮겨준다

##### 5.
 - |7|4|5|2|9|
   |---|---|---|---|---|
   | left |  |  |  | right
   | pivot |  |  |  | high
   |  |  |  |  | low
 - 다시 low를 옮기려고 하니 이미 low의 값(9)이 pivot의 값(7)보다 크고  
 low < right의 조건도 성립하지 않으므로 low의 이동을 중지한다.
 - high의 값(9)는 pivot의 값(7)보다 큼으로 왼쪽으로 이동한다.


##### 6.
 - |7|4|5|2|9|
   |---|---|---|---|---|
   | left |  |  |  | right
   | pivot |  |  | high | low
 - 현재 right의 값(2)은 pivot의 값(7)보다 작음으로 이동을 중지한다.
 - 둘의 이동이 끝난 뒤 low < high라면 둘의 값을 교환하는데 high > low임으로 
서로의 값을 교환하지 않는다.
 - 다시 처음의  반복문의 조건을 보면 low < high가 성립하지 않음으로 
low와 high 둘 다 이동을 중지한다.

##### 7.
- high의 값이 pivot의 값보다 작거나 같다면 둘의 값을 교환한다.
- 그리고 pivot의 위치 (index)를 right의 위치로 변경한다.
  - |2|4|5|7|9|
    |---|---|---|---|---|
    | left |  |  |  | right
    |  |  |  | high | low
    |  |  |  | pivot | 
- 현재 피봇의 값(7)의 위치가 정해졌다.

##### 8.
- 다시 재귀함수로 인자로 전달받은 배열의 퀵정렬을 불러오는데 2번 불러온다.
    1. 퀵정렬 (배열, left, pivot - 1)
    2. 퀵정렬 (배열, pivot + 1, right)
        - pivot의 위치는 정해졌음으로 pivot의 왼쪽 배열과 오른쪽 배열을
       다시 퀵정렬을 돌려 준다.

##### 9.
- 왼쪽은 left 0, right 2인 상태로 재귀함수에 들어가게 된다.
- 오른쪽은? left = pivot + 1 = 4, right = 4의 상태로 재귀함수에 진입한다.
  - if (right > left)의 조건이 성립하지 않아 바로 리턴되어 진다.  
    (7 (index = 3)이 정해짐과  동시에 그 오른쪽엔 9라는 숫자 하나만 존재함으로 
  오른쪽배열은 정렬이 완료되었다.)